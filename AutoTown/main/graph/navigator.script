-- Navigator stores information about graph and traffic
-- and plots routes for cars.

-- Graph

-- Edge of the graph.
Road = {}
function Road:new(from, to, width, length)

	local obj= {}
	obj.from = from
	obj.to = to
	obj.width = width
	obj.length = length
	obj.cars = 0

	-- Make object.
	setmetatable(obj, self)
	self.__index = self; return obj
end

-- How much time will a car spend on a given road.
function time_on_road(road)
	return road.length * math.max((road.cars + 1) / road.width, 1)
end

local roads = {}
-- Cars urls, for telling cars that they can speed up if possible, works as a stack.
local cars = {}
local homes = {}
local home_count = 0


-- Functions.

function add_road(home1, home2, width, length)
	roads[home1.number][home2.number] = Road:new(home1, home2, width, length)
	roads[home2.number][home1.number] = Road:new(home2, home1, width, length)
	cars[home2.number][home1.number] = {}
	cars[home1.number][home2.number] = {}
end

function add_home(home)
	roads[home] = {}
	cars[home] = {}
	home_count = home_count + 1
end

-- Increment cars counter on the road.
function add_car_riding(car, from, to)
	table.insert(cars[from][to], car)
	roads[from][to].cars = roads[from][to].cars + 1
end

-- Decrement cars counter on the road.
function remove_car(car, from, to)
	-- First car is removed, because it is added first and finish riding first.
	table.remove(cars[from][to], 1)
	roads[from][to].cars = roads[from][to].cars - 1
	for k, other_car in pairs(cars[from][to]) do
		msg.post(other_car, "go_to", {road = roads[from][to]})
	end
end

-- Plot route and return first road of it.
function first_road(start, finish)
	d = {}
	p = {}
	used = {}
	for i = 1, home_count do
		d[i] = math.huge
		used[i] = false
		p[i] = nil
	end
	d[start] = 0
	for i = 1, home_count do
		v = nil
		for j = 1, home_count do
			-- Find closest home, can be optimized.
			if not(used[j]) and (v == nil or d[j] < d[v]) then
				v = j
			end
		end
		if d[v] == math.huge then
			break
		end
		used[v] = true
		for e, road in pairs(roads[v]) do
			if d[v] + time_on_road(road) < d[e] then
				d[e] = d[v] + time_on_road(road)
				p[e] = v
			end
		end
	end

	-- Trace back the path.
	next_home = finish
	while p[next_home] ~= start do
		next_home = p[next_home]
	end
	return roads[start][next_home]
end



-- Object lifecycle.

function init(self)
	-- Add initialization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	if message_id == hash("road_is_finished") then
		remove_car(sender, message.from, message.to)
	elseif message_id == hash("where_next") then
		next_road = first_road(message.from, message.to)
		add_car_riding(sender, next_road.from.number, next_road.to.number)
		msg.post(sender, "go_to", { road = next_road })
	elseif message_id == hash("add_home") then
		add_home(message.home)
	elseif message_id == hash("add_road") then
		add_road(message.from, message.to, message.width, message.length)
	end
end

function on_input(self, action_id, action)
	-- Add input-handling code here. The game object this script is attached to
	-- must have acquired input focus:
	--
	--    msg.post(".", "acquire_input_focus")
	--
	-- All mapped input bindings will be received. Mouse and touch input will
	-- be received regardless of where on the screen it happened.
	-- Learn more: https://defold.com/manuals/input/
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end

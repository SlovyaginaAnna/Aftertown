-- Navigator stores information about graph and traffic
-- and plots routes for cars.

local c = require "scripts.coordinates"
local s = require "scripts.shop"

-- Graph

-- Edge of the graph.
Road = {}
function Road:new(from, to, width, length)

	local obj= {}
	obj.from = from
	obj.to = to
	obj.width = width
	obj.length = length
	obj.cars = 0

	-- Make object.
	setmetatable(obj, self)
	self.__index = self; return obj
end

-- How much time will a car spend on a given road.
function time_on_road(road)
	return road.length * math.max((road.cars + 1) / road.width, 1)
end

local roads = {}
-- Cars urls, for telling cars that they can speed up if possible, works as a stack.
local cars = {}
local cells = {}
local cell_count = 0


-- Functions.

-- Geometry
function area(a, b, c)
	return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)
end

function intersect_1(a, b, c, d)
	if a > b then
		a, b = b, a
	end
	if c > d then
		c, d = d, c
	end
	return math.max(a, c) <= math.min(b, d)
end

function intersect(road1, road2)
	local a1 = road1.from.position
	local b1 = road1.to.position
	local a2 = road2.from.position
	local b2 = road2.to.position
	return intersect_1(a1.x, b1.x, a2.x, b2.x)
		and intersect_1(a1.y, b1.y, a2.y, b2.y)
		and area(a1,b1,a2) * area(a1,b1,b2) < 0
		and area(a2,b2,a1) * area(a2,b2,b1) < 0
end

function gcd(a, b)
	if b < 0 then
		b = -b
	end
	if a < 0 then
		a = -a
	end
	if b == 0 then
		return math.max(a, 1)
	end
	return gcd(b, a%b)
end

function can_add_road(cell1, cell2)
	if cell1.number == cell2.number then
		return false
	end
	if math.abs(cell1.position.x - cell2.position.x) > c.cell
	or math.abs(cell1.position.y - cell2.position.y) > c.cell then
		return false
	end
	road = Road:new(cell1, cell2, 1, 1)
	for i = 1, cell_count do
		for j = 1, cell_count do
			if roads[i][j] ~= nil and 
			intersect(road, roads[i][j]) then
				return false
			end
		end
	end
	return true
end

function add_road(cell1, cell2)
	width = math.min(c.road_width[cell1.number], c.road_width[cell2.number])
	length = vmath.length(cell2.position - cell1.position)
	roads[cell1.number][cell2.number] = Road:new(cell1, cell2, width, length)
	roads[cell2.number][cell1.number] = Road:new(cell2, cell1, width, length)
	cars[cell2.number][cell1.number] = {}
	cars[cell1.number][cell2.number] = {}
	return roads[cell1.number][cell2.number]
end

function plan_roads(start, finish, sender)
	-- Center coordinates.
	start = c.indToPos(c.index(start))
	finish = c.indToPos(c.index(finish))
	local first_cell = {number = c.index(start), position = start}
	local last_cell = {number = c.index(finish), position = finish}
	if can_add_road(first_cell, last_cell) then
		local built_road = add_road(first_cell, last_cell)
		msg.post(sender, "add_road", {road = built_road })
	end
end

function add_cell(cell)
	roads[cell] = {}
	cars[cell] = {}
	cell_count = cell_count + 1
end

-- Increment cars counter on the road.
function add_car_riding(car, from, to)
	table.insert(cars[from][to], car)
	roads[from][to].cars = roads[from][to].cars + 1
end

-- Decrement cars counter on the road.
function remove_car(car, from, to)
	-- First car is removed, because it is added first and finish riding first.
	table.remove(cars[from][to], 1)
	roads[from][to].cars = roads[from][to].cars - 1
	for k, other_car in pairs(cars[from][to]) do
		msg.post(other_car, "go_to", {road = roads[from][to]})
	end
end

-- Plot route and return first road of it.
function first_road(start, finish, color)
	d = {}
	p = {}
	used = {}
	for i = 1, cell_count do
		d[i] = math.huge
		used[i] = false
		p[i] = nil
	end
	d[start] = 0
	for i = 1, cell_count do
		v = nil
		for j = 1, cell_count do
			-- Find closest cell, can be optimized.
			if not(used[j]) and (v == nil or d[j] < d[v]) then
				v = j
			end
		end
		if d[v] == math.huge then
			break
		end
		used[v] = true
		for e, road in pairs(roads[v]) do
			if d[v] + time_on_road(road) < d[e] then
				d[e] = d[v] + time_on_road(road)
				p[e] = v
			end
		end
	end
	-- Find closet shop if there is no finish specified.
	if finish == nil then
		for i = 1, #(s.shops) do
			if s.shops[i].color == color and (finish == nil or d[c.index(s.shops[i].pos)] < d[finish]) then
				finish = c.index(s.shops[i].pos)
			end
		end
	end
	-- Trace back the path.
	next_cell = finish
	while next_cell ~= nil and p[next_cell] ~= start do
		next_cell = p[next_cell]
	end
	if (start == finish) then
		return Road:new(start, finish, 1, 0)
	elseif (next_cell == nil) then
		return nil
	else
		return roads[start][next_cell]
	end
end

-- Object lifecycle.

function init(self)

end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	
end

function on_message(self, message_id, message, sender)
	if message_id == hash("road_is_finished") then
		remove_car(sender, message.from, message.to)
	elseif message_id == hash("where_next") then
		next_road = first_road(message.from, message.to, message.color)
		if next_road == nil then
			msg.post(sender, "wait")
		elseif next_road.from == next_road.to then
			msg.post(sender, "done")
		else
			add_car_riding(sender, next_road.from.number, next_road.to.number)
			msg.post(sender, "go_to", { road = next_road })
		end
	elseif message_id == hash("add_cell") then
		add_cell(message.cell)
	elseif message_id == hash("add_road") then
		plan_roads(message.from, message.to, sender)
	end
end

function on_input(self, action_id, action)
	-- Add input-handling code here. The game object this script is attached to
	-- must have acquired input focus:
	--
	--    msg.post(".", "acquire_input_focus")
	--
	-- All mapped input bindings will be received. Mouse and touch input will
	-- be received regardless of where on the screen it happened.
	-- Learn more: https://defold.com/manuals/input/
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end

-- Navigator stores information about graph and traffic
-- and plots routes for cars.

local c = require "scripts.coordinates"
local s = require "scripts.shop"

-- Graph

-- Edge of the graph.
Road = {}
function Road:new(from, to, width, length)

	local obj= {}
	obj.from = from
	obj.to = to
	obj.width = width
	obj.length = length
	obj.cars = 0

	-- Make object.
	setmetatable(obj, self)
	self.__index = self; return obj
end

-- How much time will a car spend on a given road.
function time_on_road(road)
	return road.length * math.max(math.pow(road.cars + 1, 2) / road.width, 1)
end

local roads = {}
-- Cars urls, for telling cars that they can speed up if possible, works as a stack.
local cars = {}
local cells = {}
local cell_count = 0


-- Functions.

function gcd(a, b)
	if b < 0 then
		b = -b
	end
	if a < 0 then
		a = -a
	end
	if b == 0 then
		return math.max(a, 1)
	end
	return gcd(b, a%b)
end

function can_add_road(cell1, cell2)
	if roads[cell1.number][cell2.number] ~= nil then
		return false
	elseif cell1.number == cell2.number then
		return false
	elseif math.abs(cell1.position.x - cell2.position.x) >  c.cell
	or math.abs(cell1.position.y - cell2.position.y) >  c.cell then
		return false
	elseif not c.isEmptyIndex(cell1.number) and c.road_built[cell1.number]
	or not c.isEmptyIndex(cell2.number) and c.road_built[cell2.number] then
		return false
	end

	local x1 = cell1.position.x
	local x2 = cell2.position.x
	local y1 = cell1.position.y
	local y2 = cell2.position.y
	if roads[c.index(vmath.vector3(x1, y2, 0))][c.index(vmath.vector3(x2, y1, 0))] ~= nil
	and not (x2 == x1) and not(y2 == y1) then
		return false
	end
	return true
end

function add_road(cell1, cell2)
	width = math.min(c.road_width[cell1.number], c.road_width[cell2.number])
	length = vmath.length(cell2.position - cell1.position)
	roads[cell1.number][cell2.number] = Road:new(cell1, cell2, width, length)
	roads[cell2.number][cell1.number] = Road:new(cell2, cell1, width, length)
	cars[cell2.number][cell1.number] = {}
	cars[cell1.number][cell2.number] = {}
	
	c.road_built[cell1.number] = true
	c.road_built[cell2.number] = true
	return roads[cell1.number][cell2.number]
end

function plan_roads(start, finish, sender)
	-- Center coordinates.
	start = c.colAndRowToPos(c.colAndRow(start))
	finish = c.colAndRowToPos(c.colAndRow(finish))
	local first_cell = {number = c.index(start), position = start}
	local last_cell = {number = c.index(finish), position = finish}
	if can_add_road(first_cell, last_cell) then
		local built_road = add_road(first_cell, last_cell)
		msg.post(sender, "add_road", {road = built_road })
	end
end

function remove_road(start, finish)
	start = c.colAndRowToPos(c.colAndRow(start))
	finish = c.colAndRowToPos(c.colAndRow(finish))
	local first_cell = {number = c.index(start), position = start}
	local last_cell = {number = c.index(finish), position = finish}
	c.road_built[first_cell.number] = false
	c.road_built[last_cell.number] = false
	if roads[first_cell.number][last_cell.number] ~= nil then
		if roads[first_cell.number][last_cell.number].url ~= nil then
			go.delete(roads[first_cell.number][last_cell.number].url)
		end
	end
	roads[first_cell.number][last_cell.number] = nil
	roads[last_cell.number][first_cell.number] = nil
end

function add_cell(cell)
	roads[cell] = {}
	cars[cell] = {}
	cell_count = cell_count + 1
end

-- Increment cars counter on the road.
function add_car_riding(car, from, to)
	table.insert(cars[from][to], car)
	roads[from][to].cars = roads[from][to].cars + 1
end

-- Decrement cars counter on the road.
function remove_car(car, from, to)
	-- First car is removed, because it is added first and finish riding first.
	table.remove(cars[from][to], 1)
	roads[from][to].cars = roads[from][to].cars - 1
	for k, other_car in pairs(cars[from][to]) do
		go.set(other_car, "CarsInFront", go.get(other_car, "CarsInFront") - 1)
		msg.post(other_car, "go_to", {road = roads[from][to]})
	end
end

-- Plot route and return first road of it.
function first_road(start, finish, color)
	d = {}
	p = {}
	used = {}
	for i = 1, cell_count do
		d[i] = math.huge
		used[i] = false
		p[i] = nil
	end
	d[start] = 0
	for i = 1, cell_count do
		v = nil
		for j = 1, cell_count do
			-- Find closest cell, can be optimized.
			if not(used[j]) and (v == nil or d[j] < d[v]) then
				v = j
			end
		end
		if d[v] == math.huge then
			break
		end
		used[v] = true
		for e, road in pairs(roads[v]) do
			if d[v] + time_on_road(road) < d[e] then
				d[e] = d[v] + time_on_road(road)
				p[e] = v
			end
		end
	end
	-- Find closet shop if there is no finish specified.
	if finish == nil then
		for i = 1, #(s.shops) do
			if s.shops[i].color == color and (finish == nil or d[c.index(s.shops[i].pos)] < d[finish]) then
				finish = c.index(s.shops[i].pos)
			end
		end
	end
	-- Trace back the path.
	next_cell = finish
	while next_cell ~= nil and p[next_cell] ~= start do
		next_cell = p[next_cell]
	end
	if (start == finish) then
		return Road:new(start, finish, 1, 0)
	elseif (next_cell == nil) then
		return nil
	else
		return roads[start][next_cell]
	end
end

-- Object lifecycle.

function init(self)

end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	
end

function on_message(self, message_id, message, sender)
	if message_id == hash("road_is_finished") then
		remove_car(sender, message.from, message.to)
	elseif message_id == hash("where_next") then
		next_road = first_road(message.from, message.to, message.color)
		if next_road == nil then
			msg.post(sender, "wait")
		elseif next_road.from == next_road.to then
			msg.post(sender, "done")
		else
			add_car_riding(sender, next_road.from.number, next_road.to.number)
			go.set(sender, "CarsInFront", next_road.cars - 1)
			msg.post(sender, "go_to", { road = next_road })
		end
	elseif message_id == hash("add_cell") then
		add_cell(message.cell)
	elseif message_id == hash("add_road") then
		plan_roads(message.from, message.to, sender)
	elseif message_id == hash("delete_road") then
		remove_road(message.from, message.to)
	elseif message_id == hash("add_road_url") then
		roads[message.road.from.number][message.road.to.number].url = message.url
		roads[message.road.to.number][message.road.from.number].url = message.url
	end
end

function on_input(self, action_id, action)
	-- Add input-handling code here. The game object this script is attached to
	-- must have acquired input focus:
	--
	--    msg.post(".", "acquire_input_focus")
	--
	-- All mapped input bindings will be received. Mouse and touch input will
	-- be received regardless of where on the screen it happened.
	-- Learn more: https://defold.com/manuals/input/
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
